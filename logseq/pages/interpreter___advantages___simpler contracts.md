- Following from the reduction in the need to predict the future there's also less [[complexity]] in the [[interpreter/calling contract]] itself and generally a smaller code size overall. A lot of [[branching code]] and [[struct configuration]] gives way to simply handing control back to the expression for any signal of intent and ad-hoc bean counting.
- This is similar to how [[Open Zeppelin]] enables [contract extension via [[hooks]]](https://docs.openzeppelin.com/contracts/4.x/extending-contracts). In the [[Open Zeppelin]] system the [[inheritance]] system is leveraged so that the [[parent]] provides a [[sane default]] or [[noop]] [[logic]] at some decision point then allows the [[child]] to define something more interesting/specific.
- [[Interpreter]] can be used in a similar way, treating the `[[eval]]` [[interface]] similarly to a [[hook]], where an [[entrypoint]] to the [[expression]] is set aside for a specific decision/calculation. The code that runs on the other side of the [[expression]] could be dozens of kb were it to be [[compiled]] directly into the [[interpreter/calling contract]], but is all reduced down to an external [[interface]] call and [[precompiled]] [[interpreter]] code.
- Calling the [[interpreter]] can also reduce the [[security surface area]] of the [[interpreter/calling contract]]. Any relevant concerns for the [[word]] supported by the [[interpreter]] can be handled within the [[interpreter]], such as [[overflow]], nuances of [[external interface]], etc. And associated [[tooling]] can provide [[simulation]], [[documentation]] and explanation of the [[expression]] for [[end users]] who are interested.
- The primary concern of the [[interpreter/calling contract]] is to enforce [[security]] and [[economic]] [[constraints]] such as [[reentrancy]] prevention and defining [[trust relationship]] between participants.