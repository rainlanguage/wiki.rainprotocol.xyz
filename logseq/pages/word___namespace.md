- Not to be confused with [[interpreter/namespace]].
- Every [[word]] in [[rainlang]] is just an [[alias]] to some index which in turn is an [[alias]] to some [[function pointer]] in a specific [[interpreter]]. Therefore the meaning and functionality of any given [[word]] is tightly [[coupled]] to the  [[interpreter]] that it is [[compiled]] into.
	- Even a [[word]] as "simple" as [[word/add]] could handle overflows differently, such as [[error]], silent [[overflow]] or [[saturate]]. It could also cost more or less [[gas]]. Have some arbitrary [[bug]], or simply be different [[bytecode]] due to [[compiler optimisation]] and [[compiler version]] in [[Solidity]] itself.
	- The only way to unambiguously define and reference a [[word]] is [[fully qualified]] by the [[interpreter]] that it is [[compiled]] into. For example [[word/add]] would really be `0x.../add` where `0x...` is the [[hash]] of the [[bytecode]] of the [[interpreter]]. Similarly, the index in some [[enum]] that references this [[word]] is only relevant to the [[function pointer]] list. In the same way as the [[DI pairing]] binds an [[interpreter]] and [[expression deployer]] together, where the standard [[expression deployer]] checks the [[hash]] of the [[bytecode]] and [[function pointers]] upon deployment of the [[interpreter]] it is doing [[integrity check]] for.
	- Annoyingly human brains and language are ill equipped to tracking hundreds or thousands of near-identical versions of things over a long period of time. Related is the philosophical question of the [[ship of theseus]] that commonly rears its head when designing software.
		- The simple solution of requiring every [[word]] to be written alongside the [[hash]] of the [[bytecode]] that defines it may well be the obviously correct solution for a computer, but almost instantly produces an incomprehensible forest of information for humans.
		- [[semver]] is often presented as a solution for the same problem as it exists in [[git]] commits, which are after all the same basic concept, the hash of some code/data + hashes of the history of all versions of that code/data. [[semver]] has a lot of [[semver/disadvantages]] in a [[decentralised]] environment, notably the [[centralised]] nature of assigning and deciding subjective things like "next version" and "non breaking change". We've seen in [[evm]] itself that even repricing [[gas]] can be a "breaking change" if some contract [[hardcoded]] the current [[gas]] prices, so really the bar is extremely high for some change to be "non breaking", to the point of [[semver]] being near meaningless. The [[rust]] approach for `0.0.x` [[semver]] is probably the safest, which is that it considers all `0` prefixed versions to be breaking changes, and it's simply easier for a human to remember a smallish integer like `52` than a 32 byte [[hash]].
		- concepts like "current" or "latest" are situationally useful, e.g. it is probably implied that [[word/add]] in this wiki is supposed to be something like "the opcode that is most similar to the idea of addition as it is manifested in the current `develop` branch in the [[rain]] git repository, as of the last time the wiki was updated, unless the author of the latest wiki update themselves was unaware of changes to addition, in which case they are writing about some older version that they are aware of." That MAY be useful for something relatively stable like addition or a well established standard like [[word/erc20-balance-of]] but MAY NOT be useful at all for a [[word]] that is iterated several times like [[word/call]] or [[word/get]], due to bug reports and other feedback at the [[rainlang]] level.
		- a pretty good middle ground solution is adopted by [[nix/shell]] and [[clojure]], which is that [[identity]] is associated with a [[value]].
			- > We need to move away from a notion of state as "the content of this memory block" to one of "the ***value*** currently associated with this identity". Thus an identity can be in different states at different times, but *the state itself doesn’t change*. That is, an identity is not a state, an identity ***has*** a state. Exactly one state at any point in time. And that state is a true value, i.e. it never changes. If an identity appears to change, it is because it becomes associated with different state values over time.
			  https://clojure.org/about/state
			- if you go to https://search.nixos.org/packages to search [[nix]] packages you will find that first they ask you the _[[nix]] version_ and _then_ you can search for versioned packages under that. e.g. there may well be a "latest" or "current" `nodejs` package, but that concept of "current" is pinned to a specific version of [[nix]] itself. E.g. in version 22.05 of [[nix]] `nodejs` package is version 16.17.1 of [[nodejs]] and in version 22.11 of [[nix]] the same `nodejs` package is version 18.12.1 of [[nodejs]].
			- The same concept can be found in [[datomic]] and [[datascript]] which [[logseq]] itself is written in! note that any query is NOT merely [[EAV]] but [[EAVT]], i.e. the [[EAV]] query is run against a specific transaction, i.e. a specific consistent world view as it was available in a fully [[acid]] database state
				- due to technical limitations in [[javascript]] and [[browser]] the [[datascript]] version is less good at [[EAVT]] but [[datomic]] offers this natively
			- [[blockchain]] itself also works this way, the world view is not only [[consistent]] at a given [[block height]] but every [[transaction]] within a [[block]] also sees the applied [[state]] of every [[transaction]] before it, which gives both the magical [[double spend]] protection and also the possibility of [[MEV]] attacks due to [[front running]] individual [[transaction]] when they hit the [[mempool]].
		- [[rainlang]] and [[interpreter/js]] and [[studio]] and really any [[front end]] over a [[DI pairing]] MUST provide
			- versioned [[expression metadata]]
			- that MAY have a per- [[expression metadata]]-version "current" for each included [[word]]
			- and SHOULD include [[fully qualified]] [[word]] lists in addition to "current" to support high [[lindy]] [[interpreter]]s that are already deployed and popular
			- and MUST be [[semver]] itself OR some other unambiguous [[immutable]] versioning scheme
			- and MAY be [[decentralised]] in that many possible [[expression metadata]] are possible provided they follow the basic [[data format]] (much like [[token lists]] )
			- so SHOULD be provided in un-[[yank]]able medium e.g. [[ipfs]] but MAY be [[deprecated]] especially in the case of known [[security]] issues
				- providing clear warning/explanation of known security issues is preferable to silent takedown of some [[expression metadata]]
			- and MUST be somehow meaningful to both [[expression/author]] and [[expression/caller]] in their [[Front end]] so that an [[onchain]] [[trust relationship]] can be meaningfully negotiated based on [[offchain]] information