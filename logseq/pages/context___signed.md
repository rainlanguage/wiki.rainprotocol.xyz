- The [[interpreter/calling contract]] MAY opt to allow the [[expression/caller]] to provide [[signed data]] with a [[signature]] from some [[expression/third party]]. This is useful when there is a [[trust relationship]] between the [[expression/author]] and [[expression/third party]] that the [[expression/caller]] is willing to accept. Often an [[onchain]] [[oracle]] is used as an [[expression/third party]] but technically all that is needed is some [[signed data]] [[serialised]] in a [[data format]] that the [[expression]] can read with [[word/context]] or [[word/context-row]].
	- The [[data format]] for the [[signed data]] for [[context/signed]] specifically is a [[Solidity]] [[uint256[]]]. There's really nothing special about it, just a [[dynamic array]] (i.e. length prefixed) of [[unsigned]] [[32 byte]] integers as per default evm values.
- In general the [[context/signed]] part of the [[context]] provided by the [[interpreter/calling contract]] can have arbitrarily many lists provided by arbitrarily many [[expression/third party]]. The convention is visible in [[interpreter/calling contract/flow]] where the final columns in [[context]] start with a column that lists all the [[expression/third party]] [[signer]] sequentially where each row is the [[signer]] of each subsequent column. I.e. the array of signers is a [[context]] column, and each of the arrays that those signers signed is a column.
- The [[interpreter/calling contract]] is responsible to [[authenticate]] the [[signature]] for each array included in [[context/signed]] and MUST [[revert]] the transaction if the [[signature]] is not valid. Moving this [[security sensitive]] [[boilerplate]] to the [[calling context]] and away from the [[expression/author]] automatically removes a common source of bugs when handling [[signed data]].
- The [[expression/author]] is responsible to [[word/ensure]] the [[expression/third party]] [[authorisation]] for any [[context/signed]] that is read by the [[expression]].
	- This can be as simple/inflexible as a [[hardcoded]] [[word/equal-to]] [[word/ensure]] on the [[expression/third party]] being some specific known [[address]].
	- It could be as open/flexible as [[word/ensure]] the allowed [[signer]] from a [[word/verify-v1-account-status-at-time]] as a [[KYC]] style [[oracle]] of signers, or [[word/erc721-balance-of]] to check a [[soulbound]] [[NFT]], or [[word/tier-v2-report-time-for-tier]] to check an [[ITierV2]] based membership etc.
- IN ADDITION TO [[authorisation]] of the [[signer]] there are several additional critical security considerations for the [[expression/author]] that are situational and so cannot be handled in a "one size fits all" approach by the [[interpreter/calling contract]]. Some common but non-exhaustive examples are:
	- [[replay]] of [[signed data]]. Fundamentally it is impossible to prevent someone providing the same [[signed data]] to multiple transactions or even multiple times within the same transaction. What should happen if the same piece of [[signed data]] is submitted to the [[interpreter/calling contract]] more than once? What if it is submitted again to a different contract before/after it is submitted to the [[interpreter/calling contract]]? What if it is submitted at the same time to contracts on an entirely different [[blockchain]]?
		- [[Replay]] can be **prevented** by including a [[nonce]] in the signed data and building an [[onchain]] registry of each [[nonce]] that has been used already. The [[nonce]] approach relies on the [[signer]] generating and including a [[nonce]] in the [[signed data]] in a predictable position so the [[expression]] can reference it. The [[nonce]] MUST NOT appear outside the [[signed data]] because this would allow the [[replay]] protection to be bypassed by the [[expression/caller]] forging a new [[nonce]] and reusing the same [[signed data]]. If the [[nonce]] only needs to be [[unique]] to the [[interpreter/calling contract]] then a simple registry can be built using [[word/get]] and [[word/set]].
		- [[Replay]] can be **allowed** if the [[interpreter/calling contract]] and/or [[expression/author]] can implement [[idempotent]] behaviour. This would mean that if the same [[signed data]] is provided multiple times it has the same effect overall as providing the [[signed data]] once. This can be an elegant solution as it puts no additional requirements on the [[expression/third party]] but it can be difficult to achieve in practise, especially when dealing with token transfers. The [[escrow]] contracts include an example of [[idempotent]] behaviour where users can [[withdraw]] as many times as they want but will receive `0` after the first withdrawal, until/unless further tokens are [[deposited]]. In this example the [[expression/author]] can use [[word/get]] and [[word/set]] to track both a total _potential_ amount transferrable and the _actual_ amount transferred, using the [[signed data]] merely to [[authorise]] the transfer.
		- Regardless of preventing or allowing [[Replay]] it MAY be useful to register the [[signed data]] itself which can be done most [[gas]] efficiently by [[hash]] which the [[expression/author]] can do with [[word/get]] and [[word/set]] and [[word/hash]]. This could be used to identify the [[signed data]] by its [[value]] which may be a more rich experience for the [[expression/author]] than dealing with the [[nonce]].
	- [[signed data]] must be [[unique]]. Closely related to [[replay]] issues, we have the inverse problem when the [[expression/third party]] produces the exact same [[signed data]] on multiple distinct events. Imagine a "winners list" for weekly bingo night that doesn't include the week, or more subtly includes the week but not the year (so we discover our first potential duplicate next year). In this case, if the same addresses ever win in the same order, it's impossible to tell whether the results were from 1 or 2 or 1000 duplicate events.
		- If the [[expression/third party]] is providing a [[nonce]] then the [[signed data]] will automatically be [[unique]] because the uniqueness applies to the [[signed data]] as a whole. Many [[unique]] things in [[web2]] systems such as [[uuid]] or [[sequential id]] or even [[squuid]] etc. may not be explicitly named [[nonce]] but can function as one.
		- Extra care has to be taken when assuming that a [[word/timestamp]] guarantees that some [[signed data]] is [[unique]]. This is especially true when a [[word/timestamp]] is seconds (like [[evm]]) or even milliseconds (like [[javascript]]). A LOT can happen on a single computer within a single millisecond, let alone many computers all working in parallel in a data centre. Additionally, common time sync algorithms such as [[NTP]] can exacerbate these issues by tweaking the system clock subtly under the hood. Operating systems don't even universally guarantee that time moves forward, which means that after it moves backwards it will move forward again, producing duplicate times when asked. In short it is way better for the [[expression/third party]] to provide a real [[nonce]] than have the [[expression/author]] try to rely on something like a [[word/timestamp]], but of course a [[word/timestamp]] is still better than nothing in a pinch!
	- [[signed data]] should have a [[domain separator]]. For all the reasons outlined in [EIP-712](https://eips.ethereum.org/EIPS/eip-712) in great technical detail we DO NOT want to **accidentally** use the wrong [[signed data]].
		- As a contrived but illustrative example, consider a thermometer that signs the average air temperature for every day of the week in a 7 item list. This hypothetical thermometer signs the weekly temperatures in BOTH celsius and kelvin. Imagine some [[interpreter/calling contract]] that automatically approves [[Insurance]] payouts for fire any time the temperature exceeds 200 degrees. Well, our thermometer is acting as the [[expression/third party]] and signing _kelvin_ temperatures that exceed 200 degrees every day! Clearly the thermometer needs to specify which list is kelvin and which is celsius within the [[signed data]] otherwise the [[expression/author]] can't check that they are reading the correct values, which would allow the [[expression/caller]] to provide.
		- A simple solution, which is conceptually the same solution as [[EIP-712]], is to [[hash]] together a series of known values into a [[domain separator]]. The [[expression/author]] can simply check that the the [[signed data]] includes the [[domain separator]] that they require the [[expression/third party]] to sign and [[expression/caller]] to provide. That sounds complex but in our thermometer example it could be as simple as using [[word/equal-to]] to [[word/ensure]] the [[word/hash]] is the [[hash]] of "celsius" instead of "kelvin".
			- The [[EIP-712]] lists some options for things that can be in a [[domain separator]]
				- `string name` the user readable name of signing domain, i.e. the name of the DApp or the protocol.
				- `string version` the current major version of the signing domain. Signatures from different versions are not compatible.
				- `uint256 chainId` the [EIP-155](https://eips.ethereum.org/EIPS/eip-155) chain id. The user-agent *should* refuse signing if it does not match the currently active chain.
				- `address verifyingContract` the address of the contract that will verify the signature. The user-agent *may* do contract specific phishing prevention.
				- `bytes32 salt` an disambiguating salt for the protocol. This can be used as a domain separator of last resort.
			- For [[context/signed]] it might be undesirable to include all the [[EIP-712]] options, and there might be additional options that make sense to include
				- The [[signer]] name as a string might be less relevant or redundant in a fully [[decentralised]] setting where the [[signer]] is dynamically approved/negotiated according to [[expression]] and [[trust relationship]].
				- The [[version]] is usually a good thing to include as it makes it easier to run multiple versions of [[signed data]] in parallel, especially if there is no [[expiry]] in the [[signed data]].
				- The [[chain id]] implies that the [[signer]] as an [[expression/third party]] _knows about the [[expression]]_ which is a huge and possibly invalid assumption. Consider any kind of pubsub model where a publisher broadcasts data without knowing ahead of time who the subscribers are. For example, some local sports authority reports on the outcome of matches, they have no idea what degenerate gambling contracts might be dangling off their [[signed data]], and perhaps its better that things stay that way for all involved. However, if the [[chain id]] is NOT provided in the [[domain separator]] then the [[expression/author]] MUST consider the possibility of a [[replay]] if their [[expression]] is deployed to multiple chains.
				- The [[verifying contract]] in this case is BOTH the [[interpreter/calling contract]] that will [[authenticate]] the [[signature]] and the [[expression]] that handles [[authorisation]]. This [[domain separator]] also couples the [[expression/third party]] to the [[expression]] in a way that may be impossible, like the [[chain id]] case.
				- Can't really argue with [[salt]] and in fact it's probably very useful to include, and probably the main disambiguation for an [[expression/author]]. The main problem with [[salt]] as it is presented here is that it doesn't give much practical advice on how to construct it for use by an [[expression/author]]. For example salt could be:
					- Some fixed string like "celsius" or "kelvin".
					- The URL/query string used to generate a response from a server/subgraph
					- Some arbitrary binary data not recognised as a string, or even a single byte
					- Inclusive of data that is redundant with [[version]]
					- Totally random bytes generated one time and reused later
	- [[signed data]] must be [[predictable]]. The [[expression/author]] needs to be able to write an [[expression]] that can reliably read from the [[context/signed]] by index, e.g. with [[word/context]] or [[word/context-row]].
		- Importantly the [[expression/third party]] MUST always provide [[signed data]] with every index containing some meaningful or known fallback value, as they MAY NOT have any idea which [[expression]] the [[signed data]] will be used in.
	- [[signed data]] MAY OPTIONALLY [[expire]]. At least, the [[expression/third party]] MAY provide some [[expiry]] [[word/timestamp]] but it is up to the [[expression/author]] to check and respect the [[expiry]] time.
		- It MAY be desirable to the [[expression/author]] to respect historical data from some [[expression/third party]] even if newer [[signed data]] has become available. An example could be an [[offchain]] [[price feed]] that renews itself every 10 minutes so has an [[expiry]] at the next scheduled price refresh. However, the [[expression]] could look something like an [[option]] that cares about the price at a _specific_ time NOT the current [[word/timestamp]].