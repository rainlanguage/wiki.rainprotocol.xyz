- Currently the best way to *pull* data from an existing contract is to implement some [[word]] that can read the [[interface]] and push the results onto the [[interpreter]] [[stack]].
- A good example of this is [[word/chainlink-oracle-price]] that can read price data from any chainlink price oracle using their standard `[[AggregatorV3Interface]]`. One [[word]] covers handling stale price data, rescaling decimals and supports all compliant external feed contracts across all networks that [[chainlink]] supports. All [[interpreter/calling contract]] that use the [[interpreter]] containing this [[word]] automatically support expressions that use it and benefit from the [[interpreter]] internal [[chainlink]] handling.
- As the [[expression]] itself can track [[state]] with `[[set]]`/`[[get]]` the existing [[interpreter/calling contract]] doesn't need to do anything to allow users to track counts, averages, etc. over time if they read from some external [[interface]] that has a supported [[word]].
- At the time of writing this involves opening a [[PR]] or [[forking]] the [[Rain]] repository to add a [[word]] to the [[interpreter]] directly.
- In the future it should be possible to have a "[[word pack]]" where an [[interpreter]] can further delegate processing of an individual [[word]] to support extending what can be read from an external [[interface]] by the [[expression]] itself.
- [[Rain]] [[interpreter/calling contract]] are designed to be able to both be programmable via [[expression]] and also read from each other via. [[word]] to allow for "[[expression lego]]". For example, the `[[CombineTier]]` contract can deploy an [[expression]] to merge several [[KYC]] policies into a unified access control to be used as a restriction for participation in a [[stake]] [[vault]].