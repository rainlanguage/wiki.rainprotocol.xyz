- Each [[entrypoint]] can be used to calculate/enforce/track something on behalf of the [[expression/author]], decoupled from the [[Solidity]] devs that authored the [[interpreter/calling contract]]. This is one of the main [[interpreter/advantages]].
- Once the [[expression]] is deployed the [[interpreter/calling contract]] can use an [[entrypoint]] to [[dispatch]] calls to the [[interpreter]].
- The [[EncodedDispatch]] in the [[interpreter/interface/IInterpreterV1]] combines the [[onchain]] address of the [[expression]], the [[entrypoint/index]] to run and the maximum number of [[outputs]] the [[interpreter/calling contract]] can handle. The [[interpreter/calling contract]] MUST assume the [[interpreter]] is malicious and attempt to send more than the [[maximum outputs]], but an honest [[interpreter]] can often save [[gas]] by sending only one or two values from the top of what could be a large [[stack]] internally built by the [[expression]]. If the calling contract can handle arbitrarily many [[outputs]] it MAY set the max outputs to `type(uint8).max`.
- The `uint256[][]` [[context]] is a [[sparse matrix]] of values that the [[interpreter/calling contract]] can pass to the [[interpreter]] to make available to the [[expression]] as it runs. The [[word/context]] can reference the passed [[context]] much like a spreadsheet with columns and rows. The 2D nature of [[context]] allows for [[dynamic length]] columns and logical separation of [[domain concern]]. For example, the [[Flow]] contract has a column for [[context/base]] that is the same for every call, then a column for all the signatories of additional [[context/signed]], then a column for each array of context that was signed. This allows for arbitrarily many signed proofs to be provided to the [[Flow]] contract and it is up to the [[expression]] to [[authorise]] signers assuming the calling contract will [[authenticate]] them and decide what "slots" to read out of the context.
- **One common and important item of [[context/base]] is to provide the [[msg.sender]] of the [[interpreter/calling contract]]. From the perspective of the interpreter the *[[interpreter/calling contract]]* is [[msg.sender]] and [[address(this)]] is the [[interpreter]] itself. If the [[interpreter/calling contract]] doesn't provide the [[msg.sender]] in its [[context/base]] then [[expression/author]] WILL NOT have any way to reference the real caller of the expression.**
- How the [[context]] is defined and presented is entirely up to the [[interpreter/calling contract]]. The [[expression deployer]] provides a list of [[context]] reads that it detects during the [[expression/integrity check]] so that potentially [[gas]] expensive [[context]] data (e.g. [[storage]] reads) can be skipped if the [[expression]] doesn't need them. The context read tracking is represented as a 16x16 grid of bitflags represented as a single `uint256`.
- **Extra care must be taken by the [[interpreter/calling contract]] when passing context to the [[expression]] that is provided by an external source. External data is typically trivial to manipulate unless it is signed by a trusted signer or similar. The [[interpreter/calling contract]] is responsible to [[authenticate]] each [[signature]] and additional checks that might be needed for [[expression/caller]] provided [[context]] to be useful to the [[expression]]. The benefit is that once these checks are defined, the [[expression/author]] may not need to be aware of them at all, or require much less technical knowledge (e.g. authorising vs. authenticating AND authorising).**
- The return value from the [[interpreter]] for every [[entrypoint]] is the same. Two lists of values, presumably no longer than the [[max outputs]] requested by the [[dispatch]]. The first list is the requested slice of the final [[stack]] after [[eval]] is complete and the second list is all the [[state changes]] requested by the [[expression]], e.g. via [[word/set]]. The first list MUST be read from the end (it is a [[stack]] after all) and there are some convenience methods in [[LibStackTop]] to handle that efficiently. The second [[stack]] MAY be passed back to the [[interpreter]] with the [[stateChanges]] function. If the [[interpreter/calling contract]] is running [[eval]] from a [[static]] [[evm]] context it MAY NOT call [[stateChanges]] as this would be impossible anyway. The [[expression/author]] is expected to be aware that the [[interpreter/calling contract]] they use MAY NOT support [[state changes]] some or all of the time.
- **Again, the [[interpreter/calling contract]] MUST assume the [[interpreter/malicious]] when handling the [[outputs]]. An [[interpreter/malicious]] can produce [[outputs]] that are arbitrarily garbage up to the limit of what [[Solidity]] will consider a valid `uint256[]`. This means that the garbage MUST ONLY negatively impact the [[expression/author]], and/or the [[interpreter]] used MUST be pinned to the [[expression]] and visible [[offchain]], e.g. via [[event]] logs, so the [[front end]] can index and filter out [[expression]]/[[interpreter/calling contract]] deployed under [[interpreter/malicious]].**
- **If the [[interpreter/calling contract]] chooses to apply [[state changes]] it MUST assume the [[interpreter/malicious]] and may attempt some kind of [[reentrancy]] attack. This is no different to any other [[external]] call and MUST be treated with due care. As always, the simplest solution may be to wrap [[interpreter]] [[state changes]] in a [[reentrancy/guard]] such as the one that [[Open Zeppelin]] provides, but there are other safe patterns that MAY be applied by the author of the [[interpreter/calling contract]].**