- [[context/base]] is provided by the [[interpreter/calling contract]] and are values that are expected to be useful to [[expression/author]] that are NOT directly modified/provided by [[expression/caller]]
	- [[msg.sender]] and [[address(this)]] are two obvious examples that we'd expect to see in [[context/base]] for just about any [[interpreter/calling contract]] because both of these values may be changed by the [[evm]] by the time the [[internal]] [[eval]] loop of the [[interpreter]] runs.
	- other examples include values derived from [[domain specific logic]] that is specific to the [[interpreter/calling contract]] such as the current [[vault]] [[balance]] of the [[expression/caller]] in the [[Orderbook]]. In this case we cannot allow the [[expression/caller]] to provide this value because they could lie about their [[vault]] [[balance]] in an attempt to trick their [[order book/counterparty]] or [[drain funds]] from the [[interpreter/calling contract]].
- The [[gas]] cost of reading or deriving some [[context/base]] value(s) may be high overhead to impose on every [[expression/caller]] so the [[integrity check]] returns a [[bitflag]] list of every [[word/context]] and [[word/context-row]] read within a 16x16 grid as best can be ascertained at [[compile time]]. The [[interpreter/calling contract]] will need to weigh the [[gas]] cost of [[branching code]] to check the [[bitflag]] against the costs of potentially populating [[context]] values that are never read by the [[expression]]. For values that are popular and readily available for low [[gas]] such as [[msg.sender]] it may be worth setting them unconditionally, whereas rarely used [[storage]] data or even [[external]] contract calls may be expensive enough to justify guarding the read behind the [[bitflag]] check.