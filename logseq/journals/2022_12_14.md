- #inbox
	- [[maxRedeem]] should round 'up' when calculating the number of [[shares]] when given a number of [[assets]], however I don't understand how that is supposed to work
	  I assumed it depends on the number of [[decimals]] and if we have asset with more [[decimals]] than the [[stake]] token [[decimals]]
	  Since decimal places would be lost in that calculation
	  It must be division which results in a [[fixed point]] number
	  Or theoretically would result in a [[fixed point]] value
	  Try a 2:3 ratio
	  So you get 0.6 recurring
	  it doesn't have anything to do with the [[decimals]]
	  it has to do with the [[fixed point/ratio]] that [[shares]] and [[assets]] are [[minted]] and [[burned]] at
	  if there are 9 [[shares]] and 10 [[assets]] in the [[vault]]
	  then someone [[redeem]] 3 [[shares]]
	  how many [[assets]] do they get?
	  3.3333333333..
	  [[ERC4626]] says to favour the [[vault]] so they get 3 [[assets]] and the [[remainder]] represents [[dust]] that will be trapped when everyone [[withdraw]] all the [[shares]]
	  it always [[floors]] when you [[divide]], which is the problem so that's why [[ERC4626]] is specifying something that is not default [[solidity]]
	  what if there are 9 [[shares]] and 10 [[assets]] and you want to [[mint]] 3 [[shares]]?
	  you need to [[round]] 3.333.. up to favour the [[vault]] so you have to provide 4 [[assets]]
	  Yeah I got it, you want [[dust]]
	  basically that's the summary
	  I agree the wording in [[ERC4626]] is bad
	  "it should just round correctly" is what I got from the spec
	  rounding 3.33 up to 4 isn't intuitive
	  I got that wrong the first time I make a [[vault]], before [[ERC4626]] existed
	- [[loop-n]] 
	  take 3 from stack, loop once, output 4, next loop take 3 from those 4, loop, put back 4
	  now we have 5 items
	  but we still output 4
	  so what happens to that remaining 1 item?
	  surely that doesnt end up on the main [[stack]] at last anyway, or does it?
	  in this example, input 3, output4, at each loop we are outputing 1 extra item, say we loop 8 times, we now have 8 extra items
	  where do they end up?
	  and how you know which one is the main one that will be ending up on the main [[stack]] ?
	  you can say the last one, but that doesnt seem quite right to me
	  also what happens if it outputs are less than inputs?
	  surely that’s an error? right?
	  yes
	  net effect is pops rather than pushes
	- [[loop-n]]
	  shouldnt the number of inputs and outputs be the same all the times?
	  if so then why do we have outputSize in the operand?
	  that restriction is only for do while, because we know it loops n times we can calculate the stack diff due to an input and output mismatch
	- @thedavidmeister if an [[k/v item]] doesnt exist, and you [[get]] it, would it [[stack]] 0 as a result or reverts?
	  0
	  That’s my understanding
-